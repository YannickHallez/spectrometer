#!/usr/bin/env python
## used to parse files more easily
#from __future__ import with_statement
import time
#
from pylab import *
# os
import os, time
# Numpy module
import numpy as np
# for command-line arguments
import sys
# for filtering data 
from scipy.signal import savgol_filter
# Qt4 bindings for core Qt functionalities (non-GUI)
from PyQt5 import QtCore
# Python Qt4 bindings for GUI objects
from PyQt5 import QtWidgets as QtGui
from PyQt5.QtWidgets import QMessageBox
# import the MainWindow widget from the converted .ui files
from spectrometerGUI import Ui_MplMainWindow
import seabreeze
seabreeze.use('pyseabreeze')

if len(sys.argv) == 2:
    mode = sys.argv[1]
    if mode=="test":
        from seatease.spectrometers import list_devices, Spectrometer
else:
    from seabreeze.spectrometers import list_devices, Spectrometer



try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s
class DesignerMainWindow(QtGui.QMainWindow, Ui_MplMainWindow):
  """Customization for Qt Designer created window"""
  def __init__(self, parent = None):
    # initialization of the superclass
    super(DesignerMainWindow, self).__init__(parent)
    # setup the GUI --> function generated by pyuic4
    self.setupUi(self)
    self.I0   = None
    self.I    = None 
    self.At   = None
    self.t    = None
    self.spec = None 
    self.baselineAcquired = False 
    self.spectrometerConnected = False 
    while not self.spectrometerConnected:
        try:
            print("trying to connect...")
            self.spec = Spectrometer.from_first_available()
            print("connected!")
            self.ld = self.spec.wavelengths() 
            self.spectrometerConnected = True
        except:
            time.sleep(1) 
      #msg = QMessageBox()
      #msg.setIcon(QMessageBox.Critical)        
      #msg.setText("No spectrometer found")
      #msg.setInformativeText("Please connect spectrometer")
      #msg.setWindowTitle("Error")
      #msg.exec_()
      #sys.exit(1)
    self.A = 0*self.ld 
    # Prepare plot 
    self.h1, = self.mpl.canvas.ax1.plot( self.ld, self.A, '-C0')  

  def clear(self):
    self.mpl.canvas.ax1.clear()
    self.mpl.canvas.ax2.clear()
    self.mpl.canvas.draw()

  def clearAllData(self):
    self.I0 = None
    self.I  = None 
    self.A  = 0*self.ld 
    self.At = None
    self.t  = None

  #def plotAbsorbance(self):
  #  self.mpl.canvas.ax.clear()
  #  self.mpl.canvas.ax.plot(self.ld, self.A, '-C0')
  #  #self.mpl.canvas.ax.set_xlim(0, len(self.rm) )
  #  #self.mpl.canvas.ax.set_ylim(0, max(self.rm))
  #  self.mpl.canvas.draw()

  def export(self):
    if self.radioButton_kinetics.isChecked():
      savetxt('A.txt', transpose([self.ld, self.A]))
      savetxt('At.txt', transpose([self.t, self.At]))
      msg = QMessageBox()
      msg.setIcon(QMessageBox.Information)
      msg.setText("Files A.txt and At.txt successfully exported")
      msg.exec_() 
    else:
      savetxt('A.txt', transpose([self.ld, self.A]))
      msg = QMessageBox()
      msg.setIcon(QMessageBox.Information)
      msg.setText("File A.txt successfully exported")
      msg.exec_() 

  def recordBaseline(self):
    # Acquisition parameters  
    self.spec.integration_time_micros( int(self.lineEdit_acquisitionTime.text() ) ) 
    self.numberForAverage = int( self.lineEdit_numberForAverage.text() )
    # Acquisition  
    self.I0 = self.spec.intensities() 
    self.baselineAcquired = True 
    # Message 
    msg = QMessageBox()
    msg.setIcon(QMessageBox.Information)
    msg.setText("Baseline successfully recorded.")
    msg.exec_() 


  def measureAbsorbanceOneTime(self):
      # Acquisition parameters  
      self.spec.integration_time_micros( int(self.lineEdit_acquisitionTime.text() ) ) 
      self.numberForAverage = int  ( self.lineEdit_numberForAverage.text() )
      self.ld_kinetics      = float( self.lineEdit_wavelength.text() )
      print(self.lineEdit_totalTime.text()) 
      self.T_kinetics       = float( self.lineEdit_totalTime.text() )
      self.dt_kinetics      = float( self.lineEdit_dt.text() )
      # no security here, no parameter setting, it's done elsewhere 
      I = self.spec.intensities() 
      for i in range(self.numberForAverage-1):
          I += self.spec.intensities()
          time.sleep(0.01)
      self.I = I / self.numberForAverage
      self.A = np.log10(self.I0/self.I) 
      self.A = savgol_filter(self.A, 51, 3)
      return self.A

  def measureAbsorbanceKinetics(self):
      # Acquisition parameters  
      self.spec.integration_time_micros( int(self.lineEdit_acquisitionTime.text() ) ) 
      self.numberForAverage = int  ( self.lineEdit_numberForAverage.text() )
      self.ld_kinetics      = float( self.lineEdit_wavelength.text() )
      self.T_kinetics       = float( self.lineEdit_totalTime.text() )
      self.dt_kinetics      = float( self.lineEdit_dt.text() )
      # no security here, no parameter setting, it's done elsewhere 
      t = 0. 
      self.t    = []  
      self.At   = []  
      # Initialize plot 
      self.mpl.canvas.ax2.clear()
      self.mpl.canvas.draw()
      self.h2, = self.mpl.canvas.ax2.plot( self.t, self.At, '+C0')  
      while t < self.T_kinetics*60:
          I = self.spec.intensities() 
          for i in range(self.numberForAverage-1):
              I += self.spec.intensities()
              time.sleep(0.01)
          self.I  = I / self.numberForAverage
          self.A = np.log10(self.I0/self.I) 
          self.A = savgol_filter(self.A, 51, 3)
          A_at_ld = interp(self.ld_kinetics, self.ld, self.A)
          # plot 
          self.h1.set_ydata( self.A )  
          if self.A.min() > 0:
              self.mpl.canvas.ax1.set_ylim( self.A.min()*0.9, self.A.max()*1.1 )
          else:
              self.mpl.canvas.ax1.set_ylim( self.A.min()*1.1, self.A.max()*1.1 )
          # store data 
          self.At = np.append(self.At, A_at_ld)
          self.t  = np.append(self.t, t)
          t += self.dt_kinetics
          # plot 
          self.h2.set_data( self.t, self.At )  
          self.mpl.canvas.ax2.set_xlim(0, self.t[-1]*1.1 )
          self.mpl.canvas.ax2.set_ylim(0, self.At.max()*1.1 )
          self.mpl.canvas.draw()
          # allow time for plotting 
          time.sleep(0.01)
          # wait for next point 
          time.sleep( self.dt_kinetics )
          QtCore.QCoreApplication.processEvents()
      return self.t, self.At 



  def measureAbsorbance(self):
    if self.I0 is None:
        msg = QMessageBox()
        msg.setWindowTitle("Error")
        msg.setIcon(QMessageBox.Critical)
        msg.setText("Please record baseline first")
        msg.exec_() 
        return
    if self.radioButton_oneSpectrum.isChecked():
        # Record a unique spectrum and display it 
        self.A = self.measureAbsorbanceOneTime() 
        self.h1.set_ydata( self.A )  
        self.mpl.canvas.draw()
        time.sleep(0.01)
    else:
        # kinetic mode 
        self.t, self.At = self.measureAbsorbanceKinetics()

  def Abort(self): 
      self.T_kinetics = 0.
      msg = QMessageBox()
      msg.setIcon(QMessageBox.Critical)
      msg.setText("Acquisition aborted.")
      msg.exec_() 
      return 

# create the GUI application
app = QtGui.QApplication(sys.argv)
# instantiate the main window
dmw = DesignerMainWindow()
# show it
dmw.show()
# start the Qt main loop execution, exiting from this script
# with the same return code of Qt application
sys.exit(app.exec_())

